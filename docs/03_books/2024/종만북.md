---
title: 종만북
slug: ps-jmbook
date: 2024-07-16 20:30:00
update: 2024-08-06 18:00:00
publish: true
---
> [!tip] How to read
> Read [1-8, 10, 14, 16-19, 21-25, 27-32] chapter first, and then read other parts of this book. ([ref](https://baactree.tistory.com/52?ref=ansubin.com))
> Yet, from books it is recommended to read [2-4, 6-8, 18-19, 21-23, 27-30] first.

# 3. 코딩과 디버깅에 관하여
## 3.5 변수 범위의 이해

### 자료형의 프로모션

- 부호 없는 정수형과 부호 있는 정수형이 섞여 있는 경우: 부호 없는 정수형으로 변환
	- C++의 STL 에서는 모든 컨테이너의 **`size()` 가 부호 없는 정수형인 `size_t` 로 캐스팅**됨

## 3.6 실수 자료형의 이해

### IEEE 754 표준

가장 많은 컴퓨터/컴파일러들에서 사용되는 실수 표기 방식

- 이진수로 실수를 표기
- floating-point 표기법
- 무한대, subnormal number, NaN(Not a Number) 등의 특수한 값이 존재

#### 실수의 이진법 표기

```sh
1011.101 -> 11.625
#1/2 + 0 + 1/8 = 0.625
```

#### 부동 소수점(floating-point) 표기

> 소수부분과 정수부분을 몇 비트씩 배정할지

정수부나 소수부에 너무 많은 비트 수를 배정할 경우, 큰 수를 표현하지 못하거나 정확도가 떨어지는 문제가 발생함. 따라서 **IEEE 754**를 포함한 대부분의 실수 표준에서는 소수점을 옮길 수 있도록 함.

실수 변수는 다음과 같은 3가지의 정보를 저장하게 됨.

- 부호 비트(sign bit): 양수인지 음수인지 여부
- 지수(exponent): 소수점을 몇 칸 옮겼나?
- 가수(mantissa): 소수점을 옮긴 실수의 최상위 X 비트

부호 비트는 1비트.

![[IMG_4471.jpg]]
*가수의 첫자리는 항상 1이기 때문에 따로 저장할 필요가 없다. 따라서 저장용량이 52비트뿐이지만, 53비트의 가수를 표현할 수 있다.*

#### 절대오차와 상대오차를 모두 이용한 실수 비교

```
bool doubleEqual(double a, double b) {
	double diff = fabs(a - b);
	// 절대오차가 허용 범위 안일 경우 무조건 true 반환
	if(diff < 1e-10) return true;
	// 이 이외의 경우에는 상대오차를 사용
	return diff <= 1e-8 * max(fabs(a), fabs(b));
}
```


---

# 4. 알고리즘의 시간 복잡도 분석

## 4.2 선형 시간 알고리즘

### 다이어트 현황 파악: 이동 평균 계산하기

이동평균(moving average)은 주식의 가격, 연간 국내 총생산(GDP) 등 시간에 따라 변화하는 값들을 관찰할 때 유용하게 사용할 수 있는 통계적 기준이다. **시간에 따라 관찰된 숫자들이 주어질 때 M-이동 평균은 마지막 M개의 관찰 값의 평균**으로 정의된다.

```
// 이동평균 구하기 - 선형시간 알고리즘
vector<double> movingAverage2(const vector<double>& A, int M) {
	vector<double> ret;
	int N = A.size();
	double partialSum = 0;
	for(int i = 0; i < M - 1; ++i) {
		partialSum += A[i];
	}
	for(int i = M - 1; i < N; ++i) {
		partialSum += A[i];
		ret.push_back(partialSum / M);
		partialSUm -= A[i - M + 1];
	}
	return ret;
}
```

선형 시간에 실행되는 알고리즘은 대개 우리가 찾을 수 있는 알고리즘 중 가장 좋은 알고리즘인 경우가 많다. 주어진 입력을 최소한 한 번씩 쳐다보기라도 하려면 선형 시간이 걸릴 수 밖에 없기 때문이다!

## 4.3 선형 이하 시간 알고리즘

입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘들을 선형 이하 시간(sublinear time) 알고리즘이라고 부른다. ex) 절반씩 나눠서 확인하는 경우는 밑이 2인 로그 시간이 걸린다.

### 이진 탐색(binary search)

> binsearch(A[], x) = 오름차순으로 정렬된 배열 A[]와 찾고 싶은 값 x가 주어질 때 A[i - 1] < x <= A[i] 인 i 를 반환한다. 이때 A[-1] = -infinite, A[N] = infinite 로 가정한다.

*위 함수가 배열 A[]에서 x를 삽입할 수 있는 위치 중 가장 앞에 있는 것을 반환한다고 생각하면 좀 더 쉽다. 대개의 배열이나 리스트 구현에서 i번째 위치에 새 원소를 삽입한다는 것은 i번째와 그 이후의 원소들을 뒤로 한 칸씩 밀어내고 들어간다는 뜻이다. 따라서 ==**A[]에 x가 존재하는 경우 이 함수는 첫 번째 x의 위치를 반환하고, 없는 경우 x보다 큰 첫 번째 원소를 반환**==한다.*

## 4.4 지수 시간 알고리즘

